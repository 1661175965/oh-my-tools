#! /usr/bin/env python
################################################################################
# vcproj2mak.py, generate generic Makefile based on Visual Studio project
# Copyright (C) 2008 Konstantin Ignatiev, ignatiev@users.sourceforge.net
#
# This program is distributed under the terms of GNU General Public License,
# version 2, as published by the Free Software Foundation.
# See <URL:http://www.fsf.org/licenses/gpl.txt>
#
# [Based on template Id: utility.py,v 1.2 2007/06/08 09:46:31 ignatiev Exp]
#
# $Header: /cvsroot/iimail/Misc/python/misc/vcproj2mak.py,v 1.4 2008/06/23 09:28:51 ignatiev Exp $
#
# $Log: vcproj2mak.py,v $
# Revision 1.4  2008/06/23 09:28:51  ignatiev
# New config options, bug fixes
#
# Revision 1.3  2008/06/10 18:37:30  ignatiev
# No need to 'compile' icons...
#
# Revision 1.2  2008/05/27 20:57:14  ignatiev
# Reworked, all configurations now united in single makefile
#
# Revision 1.1  2008/05/26 03:58:49  ignatiev
# Initial (working) version
#
################################################################################

import os, re, sys, getopt, os.path

cvsver = 0
CVSVersion = '$Id: vcproj2mak.py,v 1.4 2008/06/23 09:28:51 ignatiev Exp $'

def main () :
    global cvsver
    
    rev = '$Revision: 1.4 $'
    q = re.compile(r'\$' + r'Revision:\s*(.+?)\s*\$').match ( rev )
    if q : cvsver = q.group(1)
    
    # Enable this if you want to print full option list when program
    # invoked without arguments
    if len(sys.argv) <= 1 :
	print_help_and_exit()

    class Opts :
        def __init__ (self) :
            self.config = False

    opts = Opts ()

    try:
	# http://docs.python.org/lib/module-getopt.html
        params, args = getopt.gnu_getopt(sys.argv[1:], "hO:c:",
               ["help","output=","config=","version"])
    except getopt.GetoptError, (msg):
	print_help_and_exit(msg)

    mkfile = False
    for param, val in params :
        if param in ["-h","--help"] :
            print_help_and_exit ()
	elif param in ["-O","--output"] :
	    mkfile = val
        elif param in ["-c","--config"] :
            opts.config = val
	elif param == "--version" :
	    print CVSVersion
	    sys.exit(0)
	else :
	    print "CLI Option '%s' was not added to the code" % param
	    sys.exit(1)

    if len(args) < 1 :
        print_help_and_exit ("Input files NOT given")
    elif len(args) == 1 :
	vcproj = args[0]
    else :
	print_help_and_exit("Only one input file supported (%d given)" % len(args))

    if not re.compile(r'\.vcproj$').search(vcproj) :
        print_help_and_exit("Input file %s does not have required extension .vcproj" % vcproj)
        
    if mkfile == False :
	mkfile = replace_ext(vcproj,r'.vcproj$',".mak")

    print "%s => %s" % (vcproj,mkfile)

    if os.path.exists(mkfile) and not test_if_our_file(mkfile) :
        print_help_and_exit("%s exists and seems not to have been generated by %s, "
                            "cannot overwrite" % (mkfile, os.path.basename(sys.argv[0])))

    main1 (vcproj, mkfile, opts)

T_COMPILER = "compiler"
T_LINKER = "linker"
T_RESCOMP = "rc"
T = [
    ("::IntermediateDirectory", None, None, None),
    ("::OutputDirectory", None, T_COMPILER, "/Fo%s\\"),
    ("::WholeProgramOptimization", 1, T_COMPILER, "/GL"),
    ("::WholeProgramOptimization", 1, T_LINKER, "/LTCG"),
    ("VCCLCompilerTool::EnableIntrinsicFunctions", "true", T_COMPILER, "/Oi"),
    ("VCCLCompilerTool::EnableFunctionLevelLinking", "true", T_COMPILER, "/Gy"),
    ("VCCLCompilerTool::WarningLevel", 3, T_COMPILER, "/W3"),
    ("VCCLCompilerTool::DebugInformationFormat", 3, T_COMPILER, "/Zi"),
    ("VCCLCompilerTool::DebugInformationFormat", 4, T_COMPILER, "/ZI"),
    ("VCCLCompilerTool::AdditionalIncludeDirectories", None, T_COMPILER,
                        lambda x: " ".join(["/I%s"%d for d in x.split(';')])),
    ("VCCLCompilerTool::Optimization", 0, T_COMPILER, "/Od"),
    ("VCCLCompilerTool::Optimization", 2, T_COMPILER, "/O2"),
    ("VCCLCompilerTool::PreprocessorDefinitions", None, T_COMPILER,
                        lambda x: " ".join(["/D%s"%d for d in x.split(';')])),
    ("VCCLCompilerTool::MinimalRebuild", "true", T_COMPILER, "/Gm"),
    ("VCCLCompilerTool::BasicRuntimeChecks", 3, T_COMPILER, "/RTC1"),
    ("VCCLCompilerTool::UsePrecompiledHeader", 0, None, None ),
    ("VCCLCompilerTool::RuntimeLibrary", 0, T_COMPILER, "/MT"),
    ("VCCLCompilerTool::RuntimeLibrary", 1, T_COMPILER, "/MTd"),
    ("VCCLCompilerTool::RuntimeLibrary", 2, T_COMPILER, "/MD"),
    ("VCCLCompilerTool::RuntimeLibrary", 3, T_COMPILER, "/MDd"),
    ("VCCLCompilerTool::ExceptionHandling", 1, T_COMPILER, "/EHsc"),
    ("VCCLCompilerTool::UsePrecompiledHeader", 2, T_COMPILER, "/Yu"),
    ("VCResourceCompilerTool::AdditionalIncludeDirectories", None, T_RESCOMP,
                        lambda x: " ".join(["/I%s"%d for d in x.split(';')])),
    ("VCLinkerTool::SubSystem", 2, T_LINKER, " /SUBSYSTEM:WINDOWS"),
    ("VCLinkerTool::OutputFile", None, T_LINKER, "/OUT:%s"),
    ("VCLinkerTool::LinkIncremental", 1, T_LINKER, "/INCREMENTAL:NO"),
    ("VCLinkerTool::LinkIncremental", 2, T_LINKER, "/INCREMENTAL"),
    ("VCLinkerTool::GenerateDebugInformation", "true", T_LINKER, "/DEBUG"),
    ("VCLinkerTool::TargetMachine", 1, T_LINKER, "/MACHINE:X86"),
    ("VCLinkerTool::IgnoreAllDefaultLibraries", "false", None, None),
    ("VCLinkerTool::IgnoreAllDefaultLibraries", "true", T_LINKER, "/NODEFAULTLIB"),
    ("VCLinkerTool::EnableCOMDATFolding", 2, T_LINKER, "/OPT:ICF"),
    ("VCLinkerTool::OptimizeReferences", 2, T_LINKER, "/OPT:REF"),
    ("VCLinkerTool::AdditionalOptions", None, T_LINKER, "%s"),
    ("VCLinkerTool::AdditionalDependencies", None, None, None),
    ]

Tools = { T_COMPILER : ("CL","cl /nologo"),
          T_LINKER   : ("LINK", "link /nologo"),
          T_RESCOMP  : ("RC","rc") }

def t_match(t_pattern,t_val) :
    if t_pattern is None : return True
    if type(t_pattern) is type(1) : t_pattern = str(t_pattern)

    if t_pattern == t_val : return True

    return False

def main1 (vcproj, mkfile, opts) :
    import xml.dom.minidom, types

    def get_config_list(config) :
        conf_elm_list = [conf_elm for conf_elm in vcdom.getElementsByTagName("Configuration") if
                           config is False or
                           conf_elm.getAttribute("Name")[:len(config)].lower() == config.lower()]
        if len(conf_elm_list) < 1 :
            print_help_and_exit("Could not find any config matching %r" % config)
        return conf_elm_list

    def cleanup_rel_path(path) :
        if path[:2] == ".\\" :
            return path[2:]
        return path
        
    def get_file_list(filter) :
        files_elm = vcdom.getElementsByTagName("Files")[0]
        filter_elms = [e for e in files_elm.getElementsByTagName("Filter") if
                       e.getAttribute("Name")[:len(filter)].lower() == filter.lower()]
        if len(filter_elms) < 1 :
            raise "Cannot find filter '%s'" % filter
        elif len(filter_elms) > 1 :
            raise "Filter name '%s' ambigous, %d matches: (%s)" % \
                (filter, len(filter_elms), join([e.getAttribute("Name")for e in files_elm.getElementsByTagName("Filter") ]))
        else :
            filter_elm = filter_elms[0]
        return [cleanup_rel_path(file_elm.getAttribute('RelativePath')) for file_elm in filter_elm.getElementsByTagName("File")]

    def extract_config_name(conf_elm) :
        q = re.compile(r'[a-z0-9_]+', re.I).match(conf_elm.getAttribute("Name"))
        return q.group(0)
    
    def define_config_vars(conf_elm) :
        conf_vars = {}
        cfname = extract_config_name(conf_elm)
        conf_vars['ConfigurationName'] = cfname
        suffix = ""
        if len(conf_elm_list) > 1 :
            suffix = "_" + cfname
        conf_vars['OutDir'] = "$(IntDir%s)" % suffix
        return conf_vars

    def conf_substitute (val, conf_vars, mkfile_vars) :
        def substitute(x) :
            name = x.group(0)[2:-1]
            if name in conf_vars:
                return conf_vars[name]
            else :
                if name not in mkfile_vars :
                    print "Missing config var '%s'" % name
                return x.group(0)
            
        v = re.compile(r'\$\([a-z0-9_]+\)', re.I).sub ( substitute, val )
#        print "sub<%s> = <%s>" %(val,v)
        return v
            
    def process_config(conf_elm,conf_vars,mkfile_vars) :
        conf_tbl = {}
        def process_config_key(key,val) :
            conf_tbl[key] = conf_substitute(val,conf_vars, mkfile_vars)
        for k in conf_elm.attributes.keys() :
            if k not in ["Name"] :
                process_config_key("::" + k,conf_elm.getAttribute(k))
        for tool_elm in conf_elm.getElementsByTagName("Tool") :
            name = tool_elm.getAttribute('Name')
            for k in tool_elm.attributes.keys() :
                if k not in ["Name"] :
                    process_config_key(name + "::" + k,tool_elm.getAttribute(k))
        return conf_tbl

    def parse_config(conf_tbl) :
        conf_cli = {}
        for key, val in conf_tbl.iteritems() :
            match_found = []
            for t_key, t_val, sec, sub in T :
                if sec not in match_found and t_key == key and t_match(t_val,val) :
                    match_found.append(sec)
                    if sec is None : continue
                    if type(sub) is types.LambdaType :
                        sub = sub(val)
                    elif (re.compile("%s").search(sub)) :
                        sub = sub % val
                    if sec not in conf_cli : conf_cli[sec] = []
                    conf_cli[sec].append(sub)
            if not match_found :
                print "No match: %s => %s" % (key,val)
        return conf_cli
        
                    
    vcdom = xml.dom.minidom.parse(vcproj)
    sfiles,hfiles,rfiles = \
        get_file_list("source"), get_file_list("header"), get_file_list("resource")

    # resource files could be .rc files to be compiled and other types of
    # resources like icons etc.
    rcfiles = [x for x in rfiles if re.compile(r'.+\.rc$').match(x)]
    icfiles = [x for x in rfiles if not re.compile(r'.+\.rc$').match(x)]
    
    print "Source files    : %s" % ", ".join(sfiles)
    print "Header files    : %s" % ", ".join(hfiles)
    print "RC files        : %s" % ", ".join(rcfiles)
    print "Other resources : %s" % ", ".join(icfiles)

    conf_elm_list = get_config_list(opts.config)

    fh = open(mkfile,"w")

    mkfile_vars = { 'ProjectName' : replace_ext(vcproj,r'\.vcproj$', ""),
                    'SolutionDir' : ".\\",
                    'RM' : 'hrm -f' }
    
    fh.write("# -*- Makefile -*-\n")
    fh.write("# Autogenerated by %s from %s\n" % (os.path.basename(sys.argv[0]),vcproj))

    for var,val in mkfile_vars.iteritems() :
        mkwrite ( fh, "%s = %s" % (var, val) )

    if len(conf_elm_list) > 1 :
        mkwrite (fh, "default:")
        fh.write ("\t@echo \"Please select one of available configurations: %s, or 'all'\"\n" %
                 "; ".join(["'" + extract_config_name(x) + "'" for x in conf_elm_list]))
        mkwrite (fh, "clean: %s" %
                 " ".join(["clean_" + extract_config_name(x) for x in conf_elm_list]))
        mkwrite (fh, "all: %s\n" %
                 " ".join([extract_config_name(x) for x in conf_elm_list]))
        
        
    for conf_elm in conf_elm_list :
        print "\nProcessing configuration %s" % conf_elm.getAttribute("Name")
        
        cfname = extract_config_name(conf_elm)
        suffix = ""
        if len(conf_elm_list) > 1 :
            suffix = "_" + cfname

        conf_vars = define_config_vars(conf_elm)
        conf_tbl = process_config(conf_elm, conf_vars, mkfile_vars)

        # Have to push some values if they are not explicitly present
        if "VCLinkerTool::OutputFile" not in conf_tbl :
            conf_tbl["VCLinkerTool::OutputFile"] = \
                conf_substitute("$(OutDir)\$(ProjectName).exe", conf_vars, mkfile_vars)
        
        conf_cli = parse_config(conf_tbl)

        mkwrite ( fh, "IntDir%s = %s" % (suffix,conf_tbl["::IntermediateDirectory"]) )
        
        for k,v in Tools.iteritems() :
            cliops = ""
            if k in conf_cli : cliops = " ".join(conf_cli[k])
            mkwrite(fh,"%s%s = %s %s\n" % (v[0],suffix,v[1],cliops))
            
        outfile = conf_tbl["VCLinkerTool::OutputFile"]
        mkwrite ( fh, "%s : mkdir_%s %s\n" % (cfname, cfname, outfile) )
        mkwrite ( fh, "mkdir_%s :" % cfname )
        mkwrite ( fh, "\tmkdir %s" % cfname )

        link_deps = []
        for sfile in sfiles :
            ofile = "$(IntDir%s)" % suffix + "\\" + replace_ext(sfile,r'\.(cpp|cxx|c)$','.obj')
            link_deps.append(ofile)
            mkwrite ( fh, "%s: %s %s" % (ofile, sfile, " ".join(hfiles)) )
            mkwrite ( fh, "\t$(CL%s) /c %s\n" % (suffix,sfile) )

        for rfile in rcfiles :
            rofile = "$(IntDir%s)" % suffix + "\\" + replace_ext(rfile,r'\.rc$','.res')
            link_deps.append(rofile)
            mkwrite ( fh, "%s: %s %s %s" % (rofile, rfile, " ".join(hfiles), " ".join(icfiles)) )
            mkwrite ( fh, "\t$(RC%s) /fo%s %s\n" % (suffix,rofile,rfile))

        syslibs = [ "kernel32.lib", "user32.lib", "gdi32.lib", "winspool.lib", "comdlg32.lib",
                    "advapi32.lib", "shell32.lib", "ole32.lib", "oleaut32.lib", "uuid.lib",
                    "odbc32.lib", "odbccp32.lib" ]

        mkwrite ( fh, "%s : %s" % (outfile," ".join(link_deps)) )
        mkwrite ( fh, "\t$(LINK%s) %s %s %s\n" % (suffix," ".join(link_deps), " ".join(syslibs), conf_tbl.get("VCLinkerTool::AdditionalDependencies", "") ))

        mkwrite ( fh, "clean%s :" % suffix )
        mkwrite ( fh, "\t$(RM) %s %s\n" % (outfile," ".join(link_deps)) )
    fh.close()

def test_if_our_file (mkfile) :
    return True

def replace_ext(name,old,new) : # old is actually RE, new must include dot '.'
    return re.compile(old).sub("",name) + new

def mkwrite (fh,msg) :
    cmnt = "# space added"
    msg = re.compile("\\\\\\n").sub("\\ %s\n" % cmnt, msg)
    msg = re.compile("\\\\$").sub("\\ %s" % cmnt, msg)
    width = 80
    idx = 0
    str = ""
    for x in msg.split(" ") :
#        print "x=%r" % x
        if idx > 0 and idx + len(x) + 1 > width :
            str += " \\\n   " + x
            idx = 3 + len(x)
        else :
            if idx > 0 : str += " "
            str += x
            idx += 1 + len(x)
#        print "str=%r" % str
        
    fh.write (str + "\n")

def print_help_and_exit(msg=False) :
    exe = os.path.basename(sys.argv[0])

    if msg:
	print "ERROR: %s\n" % msg
	print "Usage: %s [options] <input files>" % exe
	print "... or use %s -h for more detailed help" % exe
    else :
	print '''\

%s : generate Makefile from Visual Studio project file, version '%s'

Usage:

%s [options] <Visual Studio .vcproj file>

Options are:

  -O, --output=<file>  Output file
  -c, --config=<name>  Configuration to use

  --version   print CVS version info
  -h, --help  Print this help\
''' % (exe,cvsver,exe)
	
    if msg :
	sys.exit(2)
    else :
	sys.exit(0)
	
main ()
